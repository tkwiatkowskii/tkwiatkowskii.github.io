<!doctype html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>What is dependency injection?</title>
  <meta name="description" content="Educational content on dependency injection and composition" />
  <meta name="keywords" content="dependency injection, composition, software design, learn programming" />
  <meta name="author" content="Tomasz Kwiatkowski" />
  <link rel="preload" href="/menu-icon.svg" as="image">
  <link rel="preload" href="/brightness.svg" as="image">
</head>

<body>
  <div class="layout layout--collapsed" data-theme='dark'>
    <header class="layout__header">
      <div class="header__buttons-wrapper">
        <button class="header__button">
          <img src="/brightness.svg" alt="brightness icon" class="header__icon--dynamic" />
        </button>
      </div>
      <h1 class="header__title">
        What even is
        <!-- The "d" is a workaround for consistent height on small screens -->
        <span class="header__title--effect">d</span>
      </h1>
      <nav class="header__navigation-menu">
        <div class="navigation__icons-wrapper">
          <div class="header__language-dropdown">
            <button class="header__language--en header__language">en</button>
            <button class="header__language--pl header__language">pl</button>
          </div>
          <button class="navigation__language-icon header__language-icon">
            <img src="/language-icon.svg" alt="language icon" class="" />
          </button>
          <button class="navigation__theme-icon">
            <img src="/brightness.svg" alt="brightness icon" class="" />
          </button>
        </div>
        <ol class="header__navigation-list">
          <li class="navigation__item--section">f
            dsfsdfsdfsdf
            <ol class="navigation__sublist">
              <li class="navigation__item--subsection">dsadas</li>
              <li class="navigation__item--subsection">dsdasdsaadas</li>
              <li class="navigation__item--subsection">dsadda</li>
            </ol>
          </li>
          <li class="navigation__item--section">
            dasdas
            <ol class="navigation__sublist">
              <li class="navigation__item--subsection">dsad</li>
              <li class="navigation__item--subsection">dsadas</li>
            </ol>
          </li>
          <li class="navigation__item--section">dsadas</li>
        </ol>
      </nav>
      <div class="header__language-wrapper">
        <button class="header__button--secondary header__language-icon">
          <img src="/language-icon.svg" alt="language icon" />
        </button>
        <div class="header__language-dropdown">
          <button class="header__language--en header__language">en</button>
          <button class="header__language--pl header__language">pl</button>
        </div>
      </div>
    </header>

    <nav class="layout__sidebar">
      <button class="sidebar__button">
        <img src="/menu-icon.svg" alt="hamburger menu icon" class="button__icon" />
      </button>
      <div class="sidebar__navigation-wrapper">
        <div class="sidebar__effect-container"></div>
        <ol class="sidebar__navigation-list">
          <li class="sidebar__item--section sidebar__item" tabindex="1">
            Introduction
          </li>
          <li class="sidebar__item--section sidebar__item" tabindex="2">
            Composition
          </li>
          <li class="sidebar__item--subsection sidebar__item" tabindex="3">
            dsjndjsnj
          </li>
          <li class="sidebar__item--section sidebar__item" tabindex="4">
            dsaidsajn
          </li>
          <li class="sidebar__item--subsection sidebar__item" tabindex="5">
            dsaidsajn
          </li>
        </ol>
      </div>

    </nav>
    <main class="layout__content">
      <div class="content__wrapper">
        <div class="content__section">
          <section class="section__intro">
            <h1 class="section__item">
              Introduction
            </h1>
            <p class="section__item">
              Dependency injection is a design pattern where objects receive their
              dependencies from an external source rather than creating them internally.
              This makes code less tightly coupled and easier to modify.
            </p>
            <p class="section__item">
              While it can sound
              complex, it's actually a straightforward idea that every programmer should
              know. The main reasons to learn and use dependency injection are:
            </p>
            <ul class="section__list">
              <li class="section__list-item">
                Greater flexibility by decoupling components
                and allowing easy replacement of implementations
              </li>
              <li class="section__list-item">
                Simpler, more isolated testing by injecting mock or stub dependencies
              </li>
              <li class="section__list-item">
                Improved maintainability and scalability as systems grow more complex
              </li>
            </ul>
            <div class="section__information-block">
              <div class="information__text">
                <div class="information__beginning">
                  <img src="/information-icon.svg" class="section__info-icon" alt="information icon">
                  <h3 class="section__item">Do I need to know C# to understand this?</h3>
                </div>
                The examples in this article do use specific C# related methods and keywords,
                but the knowledge of C# is absolutely not needed to be able to read this article.
                Focus on the general concepts and higher level ideas.
              </div>
            </div>
            <p class="section__item">
              Before we get to it,
              we must first talk about...
            </p>
          </section>
          <section class="section__composition">
            <h1 class="section__item">
              Composition
            </h1>
            <p class="section__item">
              Let's say we have a simple abstract
              <span class="section__code-fragment">class Database</span>
              that supports 3 actions: opening a connection to the database, closing
              the connection and executing an SQL query that returns a IDataReader object.
            </p>
            <ul class="section__list">
              <li class="section__list-item">
                Opening a connection to the database.
              </li>
              <li class="section__list-item">
                Closing the connection we opened.
              </li>
              <li class="section__list-item">
                Executing an SQL query (returning an <span class="section__code-fragment">IDataReader</span>).
              </li>
            </ul>
            <div class="code__wrapper">
              <pre class="line-numbers language-csharp">
                <code class="language-csharp">
                  public abstract class Database
                  {
                      private IDbConnection _connection;

                      public Database() { }

                      public Database(IDbConnection connection)
                      {
                          Connection = connection;
                      }

                      public required IDbConnection Connection
                      {
                          get => _connection;
                          init => _connection = value 
                            ?? throw new ArgumentNullException(nameof(value));
                      }

                      public void Open()
                      {
                          if (Connection.State != ConnectionState.Open)
                          {
                              Connection.Open();
                          }
                      }

                      public void Close()
                      {
                          if (Connection.State != ConnectionState.Closed)
                          {
                              Connection.Close();
                          }
                      }

                      public abstract IDataReader ExecuteSqlQuery(
                          string sql,
                          CommandType commandType,
                          params IDataParameter[] queryParameters);
                  }
                </code>
              </pre>
            </div>
            <p class="section__item">
              We want to make two specific database subclasses that inherit from it.
            </p>
            <ul class="section__list">
              <li class="section__list-item">
                One for
                <span class="section__code-fragment">MySQL</span>
              </li>
              <li class="section__list-item">
                One for
                <span class="section__code-fragment">SQLServer</span>
              </li>
            </ul>
            <p class="section__item">Here are the MySQL and SQLServer implementations</p>
            <div class="code__wrapper">
              <pre class="line-numbers language-csharp">
                <code class="language-csharp">
                  public sealed class MySql : Database
                  {
                      public MySql() : base() { }

                      public MySql(MySqlConnection connection) : base(connection) { }

                      public MySqlConnection MySqlConnection => (MySqlConnection)Connection;

                      public override IDataReader ExecuteSqlQuery(
                          string sql,
                          CommandType commandType = CommandType.Text,
                          params IDataParameter[] queryParameters)
                      {
                          MySqlCommand command = (MySqlCommand)Connection.CreateCommand();

                          command.CommandText = sql;
                          command.CommandType = commandType;

                          if (queryParameters != null)
                              foreach (var param in queryParameters)
                                  command.Parameters.Add(param);

                          return command.ExecuteReader(CommandBehavior.CloseConnection);
                      }
                  }

                  public sealed class SqlServer : Database
                  {
                      public SqlServer() : base() { }

                      public SqlServer(SqlConnection connection) : base(connection) { }

                      public SqlConnection SqlConnection => (SqlConnection)Connection;

                      public override IDataReader ExecuteSqlQuery(
                          string sql,
                          CommandType commandType = CommandType.Text,
                          params IDataParameter[] queryParameters)
                      {
                          SqlCommand command = (SqlCommand)Connection.CreateCommand();

                          command.CommandText = sql;
                          command.CommandType = commandType;

                          if (queryParameters != null)
                              foreach (var param in queryParameters)
                                  command.Parameters.Add(param);

                          return command.ExecuteReader(CommandBehavior.CloseConnection);
                      }
                  }
                </code>
              </pre>
            </div>
            <p class="section__item">
              This works well.
              <span class="section__code-fragment">MySQL</span>
              and
              <span class="section__code-fragment">SQLServer</span>
              are SQL databases, so it makes sense to override ExecuteSqlQuery.
            </p>
            <h3 class="section__item">
              When inheritance forces the wrong behaviour.
            </h3>
            <p class="section__item">
              Now let's assume we want to expand our hierarchy to also include our own
              database
              "<span class="section__code-fragment">SimpleDB</span>"
              that supports opening and closing connections but not executing SQL queries.
            </p>
            <p class="section__item">
              Here's how it looks:
            </p>
            <div class="code__wrapper">
              <pre class="line-numbers language-csharp" data-line="12">
                <code class="language-csharp">
                  public sealed class SimpleDb : Database
                  {
                      public SimpleDb() : base() { }

                      public SimpleDb(SimpleDbConnection connection) : base(connection) { }

                      public SimpleDbConnection SimpleDbConnection => (SimpleDbConnection)Connection;

                      public override IDataReader ExecuteSqlQuery(
                          string sql,
                          CommandType commandType = CommandType.Text,
                          params IDataParameter[] queryParameters)
                      {
                          throw new NotImplementedException("SimpleDb doesn't support SQL queries!");
                      }
                  }
                </code>
              </pre>
            </div>
            <p class="section__item">
              This feels wrong.
            </p>
            <p class="section__item">
              The base class <b>forces</b> SimpleDB to implement
              <span class="section__code-fragment">ExecuteSqlQuery</span>
              even though SimpleDB doesn't support SQL.
              The only thing we can do is throw an exception,
              which makes the method pointless.
            </p>
            <h2 class="section__item">
              Attempted fix: Separate executor class
            </h2>
            <p class="section__item">
              One way to avoid this is to move the SQL-specific behavior into its own class.
              We can create a
              <span class="section__code-fragment">DatabaseSqlQueryExecutor</span>
              class that extends
              <span class="section__code-fragment">Database</span>
              and provides the
              <span class="section__code-fragment">ExecuteSqlQuery</span>
              method:
            </p>
            <div class="code__wrapper">
              <pre class="line-numbers language-csharp">
                <code class="language-csharp">
                  public abstract class DatabaseSqlQueryExecutor : Database
                  {
                      public DatabaseSqlQueryExecutor() : base() { }

                      public DatabaseSqlQueryExecutor(IDbConnection connection) : base(connection) { }

                      public abstract IDataReader ExecuteSqlQuery(
                          string sql,
                          CommandType commandType,
                          params IDataParameter[] queryParameters);
                  }

                  public sealed class MySql : DatabaseSqlQueryExecutor
                  {                      
                      public MySql() : base() { }

                      public MySql(MySqlConnection connection) : base(connection) { }

                      public MySqlConnection MySqlConnection => (MySqlConnection)Connection;

                      public override IDataReader ExecuteSqlQuery(
                          string sql,
                          CommandType commandType = CommandType.Text,
                          params IDataParameter[] queryParameters)
                      {
                          MySqlCommand command = (MySqlCommand)Connection.CreateCommand();

                          command.CommandText = sql;
                          command.CommandType = commandType;

                          if (queryParameters != null)
                              foreach (var param in queryParameters)
                                  command.Parameters.Add(param);

                          return command.ExecuteReader(CommandBehavior.CloseConnection);
                      }
                  }

                  public sealed class SqlServer : DatabaseSqlQueryExecutor
                  {
                     // ...
                  }
                </code>
              </pre>
            </div>
            <p class="section__item">
              This way, SQL databases inherit from
              <span class="section__code-fragment">DatabaseSqlQueryExecutor</span>
              , while those that don't support SQL don't.
            </p>
            <h3 class="section__item">
              When inheritance becomes a trap
            </h3>
            <p class="section__item">
              We started with a simple
              <span class="section__code-fragment">Database</span>
              class. It had an
              <span class="section__code-fragment">ExecuteSqlQuery()</span>
              method,
              and subclasses like
              <span class="section__code-fragment">MySqlDatabase</span>
              and
              <span class="section__code-fragment">SqlServerDatabase</span>
              inherited it.
            </p>
            <p class="section__item">
              Then, we introduced an extra layer
              <span class="section__code-fragment">DatabaseSqlQueryExecutor</span>.
            </p>
            <p class="section__item">
              This now breaks everything that expected
              <span class="section__code-fragment">Database</span>
              to have the
              <span class="section__code-fragment">ExecuteSqlQuery()</span>
              method. If we keep adding database types
              (e.g., different NoSQL databases),
              we might need more subclasses, or entirely different classes like
              <span class="section__code-fragment">NoSqlDatabase</span>
              , making the hierarchy more
              complex.
            </p>
            <p class="section__item">
              We have coupled ourselves into a hierarchy that's too rigid.
            </p>
            <h2 class="section__item">
              Can we do better?
            </h2>
            <p class="section__item">
              Yes! Let's look at the three subclasses. They both share the methods
              <span class="section__code-fragment">Open()</span>
              and
              <span class="section__code-fragment">Close()</span>
              .
            </p>
            <p class="section__item">
              Instead of baking these into a shared parent class,
              we can extract this functionality into its own, independent class.
            </p>
            <h3 class="section__item">
              Extracting connection management
            </h3>
            <div class="code__wrapper">
              <pre class="line-numbers language-csharp">
                <code class="language-csharp">
                  public class DatabaseConnectionManager
                  {
                      private IDbConnection _connection;

                      public DatabaseConnectionManager() { }

                      public DatabaseConnectionManager(IDbConnection connection)
                      {
                          Connection = connection;
                      }

                      public required IDbConnection Connection
                      {
                          get => _connection;
                          init => _connection = value 
                            ?? throw new ArgumentNullException(nameof(value));
                      }

                      public void Open()
                      {
                          if (Connection.State != ConnectionState.Open)
                          {
                              Connection.Open();
                          }
                      }

                      public void Close()
                      {
                          if (Connection.State != ConnectionState.Closed)
                          {
                              Connection.Close();
                          }
                      }
                  }
                </code>
              </pre>
            </div>
            <p class="section__item">
              Now,
              <span class="section__code-fragment">
                DatabaseConnectionManager
              </span>
              represents <b>only a connection to a database</b>, which each
              of our subclasses have. We <em>can</em> make use of
              the
              <span class="section__code-fragment">
                DatabaseConnectionManager
              </span>
              if we need to, but we don't <em>have to</em>.
              If we introduce a Database that doesn't support
              opening and closing connections we can just choose
              to ignore it.
            </p>
            <h3 class="section__item">
              From inheritance to composition
            </h3>
            <p class="section__item">
              So how do we apply this to our database classes?
              Instead of subclassing
              <span class="section__code-fragment">Database</span>
              , our database classes can instead compose a
              <span class="section__code-fragment">DatabaseConnectionManager</span>
              object.
            </p>
            <div class="code__wrapper">
              <pre class="line-numbers language-csharp">
              <code class="language-csharp">
              public sealed class MySql
              {
                  private readonly DatabaseConnectionManager _connectionManager;

                  public MySql() { }

                  public MySql(DatabaseConnectionManager connectionManager)
                  {
                      ConnectionManager = connectionManager;
                  }

                  public required DatabaseConnectionManager ConnectionManager
                  {
                      init => _connectionManager = value
                          ?? throw new ArgumentNullException(nameof(ConnectionManager));
                  }

                  public MySqlConnection MySqlConnection => 
                      (MySqlConnection)_connectionManager.Connection;

                  public IDataReader ExecuteSqlQuery(
                      string sql,
                      CommandType commandType = CommandType.Text,
                      params IDataParameter[] queryParameters)
                  {
                      MySqlCommand command = 
                          (MySqlCommand)_connectionManager.Connection.CreateCommand();

                      command.CommandText = sql;
                      command.CommandType = commandType;

                      if (queryParameters != null)
                      {
                          foreach (var param in queryParameters)
                          {
                              command.Parameters.Add(param);
                          }
                      }

                      return command.ExecuteReader(CommandBehavior.CloseConnection);
                  }

                  public void Open() => _connectionManager.Open();
                  public void Close() => _connectionManager.Close();
              }

              public sealed class SqlServer
              {
                  // ...
              }

              public sealed class SimpleDb
              {
                  private readonly DatabaseConnectionManager _connectionManager;

                  public SimpleDb() { }

                  public SimpleDb(DatabaseConnectionManager connectionManager)
                  {
                      ConnectionManager = connectionManager;
                  }

                  public required DatabaseConnectionManager ConnectionManager
                  {
                      init => _connectionManager = value
                          ?? throw new ArgumentNullException(nameof(value));
                  }

                  public SimpleDbConnection SimpleDbConnection => 
                      (SimpleDbConnection)_connectionManager.Connection;

                  public void Open() => _connectionManager.Open();
                  public void Close() => _connectionManager.Close();
              }
              </code>
            </pre>
            </div>
            <h3 class="section__item">
              Extracting query execution
            </h3>
            <p class="section__item">
              Let's do the same for
              <span class="section__code-fragment">DatabaseSqlQueryExecutor</span>
            </p>
            <div class="code__wrapper">
              <pre class="line-numbers language-csharp">
                <code class="language-csharp">
                  public class DatabaseSqlQueryExecutor
                  {
                      private DatabaseConnectionManager _connectionManager;

                      public DatabaseSqlQueryExecutor() { }

                      public DatabaseSqlQueryExecutor(DatabaseConnectionManager connectionManager)
                      {
                          ConnectionManager = connectionManager;
                      }

                      public required DatabaseConnectionManager ConnectionManager
                      {
                          init => _connectionManager = value
                              ?? throw new ArgumentNullException(nameof(value));
                      }

                      public IDataReader ExecuteSqlQuery(
                          string sql,
                          CommandType commandType = CommandType.Text,
                          params IDataParameter[] queryParameters)
                      {
                          var command = _connectionManager.Connection.CreateCommand();
                          command.CommandText = sql;
                          command.CommandType = commandType;

                          if (queryParameters != null)
                          {
                              foreach (var param in queryParameters)
                              {
                                  command.Parameters.Add(param);
                              }
                          }

                          return command.ExecuteReader(CommandBehavior.CloseConnection);
                      }
                  }
                
                </code>
              </pre>
            </div>
            <p class="section__item">
              Now if a class needs to run SQL queries, we simply <em>inject</em> a
              <span class="section__code-fragment">
                DatabaseSqlQueryExecutor
              </span>
            </p>
            <h3 class="section__item">
              Putting it together
            </h3>
            <p class="section__item">
              Here's our Improved
              <span class="section__code-fragment">
                MySql
              </span>
              and
              <span class="section__code-fragment">
                SqlServer
              </span>
              classes using both components.
            </p>
            <div class="code__wrapper">
              <pre class="line-numbers language-csharp">
                <code class="language-csharp">
                  public sealed class MySql
                  {
                      private readonly DatabaseConnectionManager _connectionManager;
                      private readonly DatabaseSqlQueryExecutor _queryExecutor;

                      public MySql() { }

                      public MySql(
                          DatabaseConnectionManager connectionManager,
                          DatabaseSqlQueryExecutor queryExecutor)
                      {
                          ConnectionManager = connectionManager;
                          QueryExecutor = queryExecutor;
                      }

                      public required DatabaseConnectionManager ConnectionManager
                      {
                          init => _connectionManager = value
                              ?? throw new ArgumentNullException(nameof(ConnectionManager));
                      }

                      public required DatabaseSqlQueryExecutor QueryExecutor
                      {
                          init => _queryExecutor = value
                              ?? throw new ArgumentNullException(nameof(QueryExecutor));
                      }

                      public MySqlConnection MySqlConnection =>
                          (MySqlConnection)_connectionManager.Connection;

                      public MySqlDataReader ExecuteSqlQuery(
                          string sql,
                          CommandType commandType = CommandType.Text,
                          params IDataParameter[] queryParameters)
                      {
                          return (MySqlDataReader)
                              _queryExecutor.ExecuteSqlQuery(sql, commandType, queryParameters);
                      }

                      public void Open() => _connectionManager.Open();
                      public void Close() => _connectionManager.Close();
                  }

                  public sealed class SqlServer
                  {
                      // ...
                  }
                </code>
              </pre>
            </div>
            <h3 class="section__item">
              Why this is better
            </h3>
            <p class="section__item">
              This is the beauty of composition:
            </p>
            <ul class="section__list">
              <li class="section__list-item">
                <b>Need connection management?</b> Use
                <span class="section__code-fragment">DatabaseConnectionManager</span>.
              </li>
              <li class="section__list-item">
                <b>Need to execute SQL queries?</b> Use
                <span class="section__code-fragment">DatabaseSqlQueryExecutor</span>.
              </li>
              <li class="section__list-item">
                <b>Don't need one of them?</b> Don't include it.
              </li>
            </ul>
            <p class="section__item">
              We have significantly improved on the flexibility of our architecture.
            </p>
            <p class="section__item">
              ...But haven't we lost something along the way?
            </p>
          </section>
          <section class="section__interfaces">
            <h1 class="section__item">
              Interfaces
            </h1>
            <p class="section__item">
              Let's look back at the relationships between classes we've had at the beginning.
            </p>
            <figure class="section__uml-wrapper">
              <picture class="section__uml-inheritance-picture">
                <source srcset="/uml/uml-inheritance-light.svg" media="(prefers-color-scheme: light)"
                  class="section__uml-image">
                <source srcset="/uml/uml-inheritance-dark.svg" media="(prefers-color-scheme: dark)"
                  class="section__uml-image">
                <img src="/uml/uml-inheritance-dark.svg" alt="UML inheritance diagram" class="section__uml-image">
              </picture>
              <figcaption>
                First inheritance structure
              </figcaption>
            </figure>
            <h2 class="section__item">Contracts are expectations</h2>
            <p class="section__item">
              The main
              <span class="section__code-fragment">Database</span>
              forms a contract that all of its inheriting children must follow.
            </p>
            <p class="section__item">
              The contracts says this:
              <em>
                "All of my children will have at least these methods
                and these properties"
              </em>.
            </p>
            <p class="section__item">
              This allows us for example to create a
              <span class="section__code-fragment">DatabaseFactory</span>
              class that dynamically creates different
              <span class="section__code-fragment">Database</span>
              subclasses.
            </p>
            <h3 class="section__item">Database factory implementation</h3>
            <div class="code__wrapper">
              <pre class="line-numbers language-csharp">
                <code class="language-csharp">
                  public enum DatabaseType
                  {
                      MySql,
                      SqlServer,
                      SimpleDb
                  }

                  public static class DatabaseFactory
                  {
                      public static Database CreateDatabase(DatabaseType type, IDbConnection connection)
                      {
                          return type switch
                          {
                              DatabaseType.MySql => 
                                  new MySql((MySqlConnection)connection),
                              DatabaseType.SqlServer => 
                                  new SqlServer((SqlConnection)connection),
                              DatabaseType.SimpleDb => 
                                  new SimpleDb((SimpleDbConnection)connection),
                              _ => throw new 
                                  ArgumentException("Unsupported database type", nameof(type))
                          };
                      }
                  }
                </code>
              </pre>
            </div>
            <p class="section__item">
              Why can
              <span class="section__code-fragment">
                DatabaseFactory
              </span>
              do this?
            </p>
            <p class="section__item">
              All children inheriting from
              <span class="section__code-fragment">
                Database
              </span>
              fulfill the same contract imposed by the parent. That's why
              our factory knows that each subclass object returned will
              also qualify as a
              <span class="section__code-fragment">
                Database
              </span>
              object.
            </p>
            <p class="section__item">
              Now let's take a loot at the relationship diagram after
              composing our classes
            </p>
            <figure class="section__uml-wrapper">
              <picture class="section__uml-no-inheritance-picture">
                <source srcset="/uml/uml-no-inheritance-light.svg" media="(prefers-color-scheme: light)"
                  class="section__uml-image">
                <source srcset="/uml/uml-no-inheritance-dark.svg" media="(prefers-color-scheme: dark)"
                  class="section__uml-image">
                <img src="/uml/uml-no-inheritance-dark.svg" alt="UML no inheritance diagram" class="section__uml-image">
              </picture>
              <figcaption>
                After composing our classes
              </figcaption>
            </figure>
            <p class="section__item">
              Notice that the classes aren't pointing at anything anymore.
            </p>
            <p class="section__item">
              If we tried implementing the factory class now we'd get an error because there is no
              <span class="section__code-fragment">Database</span>
              <b>contract</b> that our subclasses are fulfilling.
            </p>
          </section>
          <h2 class="section__item">
            Interfaces are contracts
          </h2>
          <p class="section__item">
            Let's create an interface
            <span class="section__code-fragment">IDatabaseConnection</span>
            that will restore the behaviour we've had before.
          </p>
          <div class="code__wrapper">
            <pre class="line-numbers language-csharp">
              <code class="language-csharp">
                public interface IDatabaseConnection
                {
                    void Open();
                    void Close();
                }
              </code>
            </pre>
          </div>
          <p class="section__item">
            Let's implement this interface. We only have to change three lines.
          </p>
          <div class="code__wrapper">
            <pre class="line-numbers language-csharp">
              <code class="language-csharp">
                public sealed class MySql : IDatabaseConnection
                public sealed class SqlServer : IDatabaseConnection
                public sealed class SimpleDb : IDatabaseConnection
              </code>
            </pre>
          </div>
          <p class="section__item">
            What's happened?
          </p>
          <p class="section__item">
            Now our classes are fulfilling contracts again. Just
            that now, the contracts are being served if the form of interfaces.
            By implementing an interface we are also serving a contract at the same time.
          </p>
          <p class="section__item">Let's try reimplementing back our
            <span class="section__code-fragment">DatabaseFactory</span>
            class
          </p>
          <h3 class="section__item">
            Interfaced factory implementation
          </h3>
          <div class="code__wrapper">
            <pre class="line-numbers language-csharp">
              <code class="language-csharp">
                public enum DatabaseType
                {
                    MySql,
                    SqlServer,
                    SimpleDb
                }

                public static class DatabaseFactory
                {
                    public static IDatabaseConnection CreateDatabase(DatabaseType type, 
                                                                    IDbConnection connection)
                    {
                        var connectionManager = new DatabaseConnectionManager(connection);

                        return type switch
                        {
                            DatabaseType.MySql => 
                                new MySql(connectionManager, 
                                          new DatabaseSqlQueryExecutor(connectionManager)),
                            DatabaseType.SqlServer => 
                                new SqlServer(connectionManager, 
                                              new DatabaseSqlQueryExecutor(connectionManager)),
                            DatabaseType.SimpleDb => 
                                new SimpleDb(connectionManager),
                            _ => throw new ArgumentException("Unsupported database type", nameof(type))
                        };
                    }
                }
              </code>
            </pre>
          </div>
          <p class="section__item">
            Great, we've gone back to what we've had before.
            We could tighten up the hierarchy with a
            <span class="section__code-fragment">
              IDatabaseSqlQueryExecutor
            </span>
            interface but I won't be covering that.
          </p>
          <p class="section__item">
            We're now ready to finally tackle dependency injection.
          </p>
          </section>
          <section class="section__dependency-injecton">
            <h1 class="section__item">
              Dependency injection
            </h1>
            <div class="section__information-block">
              <div class="information__text">
                <div class="information__beginning">
                  <img src="/information-icon.svg" class="section__info-icon" alt="information icon">
                  <h3 class="section__item">dasdasd</h3>
                </div>
                dsadasdasdsadasdas dsadas dasdas
              </div>
            </div>
            <h3 class="section__item">dsadasdas</h3>
            <ul class="section__list">
              <li class="section__list-item">sadasdasd</li>
              <li class="section__list-item">dasdasdasd</li>
              <li class="section__list-item">dasdasdas</li>
            </ul>
          </section>
        </div>
      </div>
    </main>

    <footer class="layout__footer">
      <a href="https://github.com/tkwiatkowskii" class="footer__github-icon" target="_blank" rel="noopener noreferrer">
        <img src="/github-mark-white.svg" alt="github link icon">
      </a>
      <address class="footer__contact-information">
        <a href="mailto:tomaszkwiatkowski191@gmail.com">tomaszkwiatkowski191@gmail.com</a>
      </address>
    </footer>
  </div>
  <script type="module" src="/src/scripts/main.ts" defer></script>
</body>

</html>