<!doctype html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>What is dependency injection?</title>
  <meta name="description" content="Educational content on dependency injection and composition" />
  <meta name="keywords" content="dependency injection, composition, software design, learn programming" />
  <meta name="author" content="Tomasz Kwiatkowski" />
  <link rel="preload" href="/menu-icon.svg" as="image">
  <link rel="preload" href="/brightness.svg" as="image">
</head>

<script async src="https://www.googletagmanager.com/gtag/js?id=G-Z0PS8J7E2E"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() { dataLayer.push(arguments); }
  gtag('js', new Date());

  gtag('config', 'G-Z0PS8J7E2E');
</script>

<body>
  <div class="layout layout--collapsed" data-theme='dark'>
    <header class="layout__header">
      <div class="header__buttons-wrapper">
        <button class="header__button">
          <img src="/brightness.svg" alt="brightness icon" class="header__icon--dynamic" />
        </button>
      </div>
      <h1 class="header__title">
        What even is
        <!-- The "d" is a workaround for consistent height on small screens -->
        <span class="header__title--effect">d</span>
      </h1>
      <nav class="header__navigation-menu">
        <div class="navigation__icons-wrapper">
          <div class="header__language-dropdown header__language-dropdown--mobile">
            <button class="header__language--en header__language">en</button>
            <button class="header__language--pl header__language">pl</button>
          </div>
          <button class="navigation__language-icon header__language-icon">
            <img src="/language-icon.svg" alt="language icon" class="" />
          </button>
          <button class="navigation__theme-icon">
            <img src="/brightness.svg" alt="brightness icon" class="" />
          </button>
        </div>
        <ol class="header__navigation-list">
          <li class="navigation__item-section navigation__item-section--short">
            <a href="#introduction">Introduction</a>
          </li>
          <li class="navigation__item-section">
            <a href="#composition">Composition</a>
            <ol class="navigation__sublist">
              <li class="navigation__item--subsection"><a href="#attempted-fix">Attempted fix: Separate
                  executorclass</a></li>
              <li class="navigation__item--subsection"><a href="#can-we-do-better">Can we do better?</a></li>
              <li class="navigation__item--subsection"><a href="#from-inheritance">From inheritance to composition</a>
              </li>
              <li class="navigation__item--subsection"><a href="#putting-it-together">Putting it together</a></li>
              <li class="navigation__item--subsection"><a href="#why-better">Why this is better</a></li>
            </ol>
          </li>
          <li class="navigation__item-section">
            <a href="#interfaces">Interfaces</a>
            <ol class="navigation__sublist">
              <li class="navigation__item--subsection"><a href="#contracts-are-expectations">Contracts are
                  expectations</a></li>
              <li class="navigation__item--subsection"><a href="#interfaces-as-contracts">Interfaces as contracts</a>
              </li>
              <li class="navigation__item--subsection"><a href="#from-inheritance-to-contracts">From inheritance to
                  flexible contracts</a></li>
            </ol>
          </li>
          <li class="navigation__item-section">
            <a href="#dependency-injection">Dependency injection</a>
            <ol class="navigation__sublist">
              <li class="navigation__item--subsection"><a href="#what-does-injection-mean">What does injection mean?</a>
              </li>
              <li class="navigation__item--subsection"><a href="#testing-with-di">Testing with dependency injection</a>
              </li>
              <li class="navigation__item--subsection"><a href="#injection-factory">Using a factory for injection</a>
              </li>
              <li class="navigation__item--subsection"><a href="#puzzle-piece">The puzzle piece pattern</a></li>
            </ol>
          </li>
          <li class="navigation__item-section navigation__item-section--short">
            <a href="#conclusion">Conclusion</a>
          </li>
        </ol>
      </nav>
      <div class="header__language-wrapper">
        <button class="header__button--secondary header__language-icon">
          <img src="/language-icon.svg" alt="language icon" />
        </button>
        <div class="header__language-dropdown">
          <button class="header__language--en header__language">en</button>
          <button class="header__language--pl header__language">pl</button>
        </div>
      </div>
    </header>

    <nav class="layout__sidebar">
      <button class="sidebar__button">
        <img src="/menu-icon.svg" alt="hamburger menu icon" class="button__icon" />
      </button>
      <div class="sidebar__navigation-wrapper">
        <div class="sidebar__effect-container"></div>
        <ol class="sidebar__navigation-list">
          <li class="sidebar__item--section sidebar__item" tabindex="1">
            <a href="#introduction">Introduction</a>
          </li>
          <li class="sidebar__item--section sidebar__item" tabindex="2">
            <a href="#composition">Composition</a>
          </li>
          <li class="sidebar__item--subsection sidebar__item" tabindex="3">
            <a href="#attempted-fix">Attempted fix: Separate executor class</a>
          </li>
          <li class="sidebar__item--subsection sidebar__item" tabindex="4">
            <a href="#can-we-do-better">Can we do better?</a>
          </li>
          <li class="sidebar__item--subsection sidebar__item" tabindex="5">
            <a href="#from-inheritance">From inheritance to composition</a>
          </li>
          <li class="sidebar__item--subsection sidebar__item" tabindex="6">
            <a href="#putting-it-together">Putting it together</a>
          </li>
          <li class="sidebar__item--subsection sidebar__item" tabindex="7">
            <a href="#why-better">Why this is better</a>
          </li>
          <li class="sidebar__item--section sidebar__item" tabindex="8">
            <a href="#interfaces">Interfaces</a>
          </li>
          <li class="sidebar__item--subsection sidebar__item" tabindex="9">
            <a href="#contracts-are-expectations">Contracts are expectations</a>
          </li>
          <li class="sidebar__item--subsection sidebar__item" tabindex="10">
            <a href="#interfaces-as-contracts">Interfaces as contracts</a>
          </li>
          <li class="sidebar__item--subsection sidebar__item" tabindex="11">
            <a href="#from-inheritance-to-contracts">From inheritance to flexible contracts</a>
          </li>
          <li class="sidebar__item--section sidebar__item" tabindex="12">
            <a href="#dependency-injection">Dependency injection</a>
          </li>
          <li class="sidebar__item--subsection sidebar__item" tabindex="13">
            <a href="#what-does-injection-mean">What does injection mean?</a>
          </li>
          <li class="sidebar__item--subsection sidebar__item" tabindex="14">
            <a href="#testing-with-di">Testing with dependency injection</a>
          </li>
          <li class="sidebar__item--subsection sidebar__item" tabindex="15">
            <a href="#injection-factory">Using a factory for injection</a>
          </li>
          <li class="sidebar__item--subsection sidebar__item" tabindex="16">
            <a href="#puzzle-piece">The puzzle piece pattern</a>
          </li>
          <li class="sidebar__item--section sidebar__item" tabindex="17">
            <a href="#conclusion">Conclusion</a>
          </li>
        </ol>
      </div>

    </nav>
    <main class="layout__content">
      <div class="content__wrapper">
        <div class="content__section">
          <section class="section__intro">
            <h1 class="section__item" id="introduction">
              Wprowadzenie
            </h1>
            <p class="section__item">
              Dependency injection to wzorzec projektowy, w którym obiekty otrzymują swoje zależności z zewnętrznego
              źródła, zamiast tworzyć je wewnętrznie.
              Dzięki temu kod staje się mniej ściśle powiązany i łatwiejszy do modyfikacji.
            </p>
            <p class="section__item">
              Chociaż może brzmieć to skomplikowanie, w rzeczywistości to prosta idea, którą powinien znać każdy
              programista.
              Główne powody, aby nauczyć się i stosować wstrzykiwanie zależności, to:
            </p>
            <ul class="section__list">
              <li class="section__list-item">
                Większa elastyczność poprzez rozdzielenie komponentów i łatwą wymianę implementacji
              </li>
              <li class="section__list-item">
                Prostsze, bardziej izolowane testowanie dzięki wstrzykiwaniu atrap lub zamienników zależności
              </li>
              <li class="section__list-item">
                Lepsza łatwość utrzymania i skalowalność w miarę wzrostu złożoności systemów
              </li>
            </ul>
            <div class="section__information-block">
              <div class="information__text">
                <div class="information__beginning">
                  <img src="/information-icon.svg" class="section__info-icon" alt="ikona informacyjna">
                  <h3 class="section__item">Czy muszę znać C#, aby to zrozumieć?</h3>
                </div>
                Przykłady w tym artykule wykorzystują konkretne metody i słowa kluczowe związane z C#,
                ale znajomość C# absolutnie nie jest wymagana, aby móc przeczytać ten artykuł.
                Skup się na ogólnych koncepcjach i ideach wyższego poziomu.
              </div>
            </div>
            <p class="section__item">
              Zanim do tego przejdziemy,
              musimy najpierw porozmawiać o...
            </p>
          </section>
          <section class="section__composition">
            <h1 class="section__item" id="composition">
              Kompozycja
            </h1>
            <p class="section__item">
              Załóżmy, że mamy prostą abstrakcyjną
              <span class="section__code-fragment">class Database</span>,
              która obsługuje 3 działania:
            </p>
            <ul class="section__list">
              <li class="section__list-item">
                Otwarcie połączenia z bazą danych.
              </li>
              <li class="section__list-item">
                Zamknięcie otwartego połączenia.
              </li>
              <li class="section__list-item">
                Wykonanie zapytania SQL (zwracającego <span class="section__code-fragment">IDataReader</span>).
              </li>
            </ul>
            <div class="code__wrapper">
              <pre class="line-numbers language-csharp">
                <code class="language-csharp">
                  public abstract class Database
                  {
                      private IDbConnection _connection;

                      public Database() { }

                      public Database(IDbConnection connection)
                      {
                          Connection = connection;
                      }

                      public required IDbConnection Connection
                      {
                          get => _connection;
                          init => _connection = value 
                            ?? throw new ArgumentNullException(nameof(value));
                      }

                      public void Open()
                      {
                          if (Connection.State != ConnectionState.Open)
                          {
                              Connection.Open();
                          }
                      }

                      public void Close()
                      {
                          if (Connection.State != ConnectionState.Closed)
                          {
                              Connection.Close();
                          }
                      }

                      public abstract IDataReader ExecuteSqlQuery(
                          string sql,
                          CommandType commandType,
                          params IDataParameter[] queryParameters);
                  }
                </code>
              </pre>
            </div>
            <p class="section__item">
              Chcemy stworzyć dwie konkretne podklasy bazy danych, które będą po niej dziedziczyć.
            </p>
            <ul class="section__list">
              <li class="section__list-item">
                Jedną dla
                <span class="section__code-fragment">MySQL</span>
              </li>
              <li class="section__list-item">
                Drugą dla
                <span class="section__code-fragment">SQLServer</span>
              </li>
            </ul>
            <p class="section__item">Oto implementacje dla MySQL i SQLServer</p>
            <div class="code__wrapper">
              <pre class="line-numbers language-csharp">
                <code class="language-csharp">
                  public sealed class MySql : Database
                  {
                      public MySql() : base() { }

                      public MySql(MySqlConnection connection) : base(connection) { }

                      public MySqlConnection MySqlConnection => (MySqlConnection)Connection;

                      public override IDataReader ExecuteSqlQuery(
                          string sql,
                          CommandType commandType = CommandType.Text,
                          params IDataParameter[] queryParameters)
                      {
                          MySqlCommand command = (MySqlCommand)Connection.CreateCommand();

                          command.CommandText = sql;
                          command.CommandType = commandType;

                          if (queryParameters != null)
                              foreach (var param in queryParameters)
                                  command.Parameters.Add(param);

                          return command.ExecuteReader(CommandBehavior.CloseConnection);
                      }
                  }

                  public sealed class SqlServer : Database
                  {
                      public SqlServer() : base() { }

                      public SqlServer(SqlConnection connection) : base(connection) { }

                      public SqlConnection SqlConnection => (SqlConnection)Connection;

                      public override IDataReader ExecuteSqlQuery(
                          string sql,
                          CommandType commandType = CommandType.Text,
                          params IDataParameter[] queryParameters)
                      {
                          SqlCommand command = (SqlCommand)Connection.CreateCommand();

                          command.CommandText = sql;
                          command.CommandType = commandType;

                          if (queryParameters != null)
                              foreach (var param in queryParameters)
                                  command.Parameters.Add(param);

                          return command.ExecuteReader(CommandBehavior.CloseConnection);
                      }
                  }
                </code>
              </pre>
            </div>
            <p class="section__item">
              To działa dobrze.
              <span class="section__code-fragment">MySQL</span>
              i
              <span class="section__code-fragment">SQLServer</span>
              to bazy danych SQL, więc nadpisanie ExecuteSqlQuery ma sens.
            </p>
            <h3 class="section__item" id="when-inheritance">
              Gdy dziedziczenie wymusza niewłaściwe zachowanie
            </h3>
            <p class="section__item">
              Załóżmy teraz, że chcemy rozszerzyć naszą hierarchię o naszą własną bazę danych
              "<span class="section__code-fragment">SimpleDB</span>",
              która obsługuje otwieranie i zamykanie połączeń, ale nie obsługuje zapytań SQL.
            </p>
            <p class="section__item">
              Oto jak to wygląda:
            </p>
            <div class="code__wrapper">
              <pre class="line-numbers language-csharp" data-line="12">
                <code class="language-csharp">
                  public sealed class SimpleDb : Database
                  {
                      public SimpleDb() : base() { }

                      public SimpleDb(SimpleDbConnection connection) : base(connection) { }

                      public SimpleDbConnection SimpleDbConnection => (SimpleDbConnection)Connection;

                      public override IDataReader ExecuteSqlQuery(
                          string sql,
                          CommandType commandType = CommandType.Text,
                          params IDataParameter[] queryParameters)
                      {
                          throw new NotImplementedException("SimpleDb doesn't support SQL queries!");
                      }
                  }
                </code>
              </pre>
            </div>
            <p class="section__item">
              To wydaje się błędne.
            </p>
            <p class="section__item">
              Klasa bazowa <b>wymusza</b> na SimpleDB implementację
              <span class="section__code-fragment">ExecuteSqlQuery</span>,
              mimo że SimpleDB nie obsługuje SQL.
              Jedyne, co możemy zrobić, to wyrzucić wyjątek,
              co sprawia, że metoda staje się bezużyteczna.
            </p>
            <h2 class="section__item" id="attempted-fix">
              Próba naprawy: Oddzielna klasa wykonawcy
            </h2>
            <p class="section__item">
              Jednym ze sposobów uniknięcia tego problemu jest przeniesienie zachowania specyficznego dla SQL do osobnej
              klasy.
              Możemy stworzyć
              <span class="section__code-fragment">DatabaseSqlQueryExecutor</span>,
              która dziedziczy po
              <span class="section__code-fragment">Database</span>
              i dostarcza metodę
              <span class="section__code-fragment">ExecuteSqlQuery</span>:
            </p>
            <div class="code__wrapper">
              <pre class="line-numbers language-csharp">
                <code class="language-csharp">
                  public abstract class DatabaseSqlQueryExecutor : Database
                  {
                      public DatabaseSqlQueryExecutor() : base() { }

                      public DatabaseSqlQueryExecutor(IDbConnection connection) : base(connection) { }

                      public abstract IDataReader ExecuteSqlQuery(
                          string sql,
                          CommandType commandType,
                          params IDataParameter[] queryParameters);
                  }

                  public sealed class MySql : DatabaseSqlQueryExecutor
                  {                      
                      public MySql() : base() { }

                      public MySql(MySqlConnection connection) : base(connection) { }

                      public MySqlConnection MySqlConnection => (MySqlConnection)Connection;

                      public override IDataReader ExecuteSqlQuery(
                          string sql,
                          CommandType commandType = CommandType.Text,
                          params IDataParameter[] queryParameters)
                      {
                          MySqlCommand command = (MySqlCommand)Connection.CreateCommand();

                          command.CommandText = sql;
                          command.CommandType = commandType;

                          if (queryParameters != null)
                              foreach (var param in queryParameters)
                                  command.Parameters.Add(param);

                          return command.ExecuteReader(CommandBehavior.CloseConnection);
                      }
                  }

                  public sealed class SqlServer : DatabaseSqlQueryExecutor
                  {
                     // ...
                  }
                </code>
              </pre>
            </div>
            <p class="section__item">
              W ten sposób bazy danych SQL dziedziczą po
              <span class="section__code-fragment">DatabaseSqlQueryExecutor</span>,
              a te, które nie obsługują SQL, już nie.
            </p>
            <h3 class="section__item" id="trap">
              Kiedy dziedziczenie staje się pułapką
            </h3>
            <p class="section__item">
              Zaczęliśmy od prostej klasy
              <span class="section__code-fragment">Database</span>.
              Miała metodę
              <span class="section__code-fragment">ExecuteSqlQuery()</span>,
              a podklasy, takie jak
              <span class="section__code-fragment">MySqlDatabase</span>
              i
              <span class="section__code-fragment">SqlServerDatabase</span>,
              po niej dziedziczyły.
            </p>
            <p class="section__item">
              Następnie wprowadziliśmy dodatkową warstwę
              <span class="section__code-fragment">DatabaseSqlQueryExecutor</span>.
            </p>
            <p class="section__item">
              To teraz psuje wszystko, co oczekiwało, że
              <span class="section__code-fragment">Database</span>
              będzie mieć metodę
              <span class="section__code-fragment">ExecuteSqlQuery()</span>.
              Jeśli będziemy dodawać kolejne typy baz danych (np. różne bazy NoSQL),
              możemy potrzebować więcej podklas albo zupełnie innych klas, takich jak
              <span class="section__code-fragment">NoSqlDatabase</span>,
              co sprawi, że hierarchia stanie się bardziej złożona.
            </p>
            <p class="section__item">
              Wpakowaliśmy się w hierarchię, która jest zbyt sztywna.
            </p>
            <h2 class="section__item" id="can-we-do-better">
              Czy możemy zrobić to lepiej?
            </h2>
            <p class="section__item">
              Tak! Spójrzmy na trzy podklasy. Wszystkie one współdzielą metody
              <span class="section__code-fragment">Open()</span>
              i
              <span class="section__code-fragment">Close()</span>.
            </p>
            <p class="section__item">
              Zamiast umieszczać to w klasie bazowej,
              możemy wyodrębnić tę funkcjonalność do osobnej, niezależnej klasy.
            </p>
            <h3 class="section__item" id="extracting-connection">
              Wyodrębnienie zarządzania połączeniem
            </h3>
            <div class="code__wrapper">
              <pre class="line-numbers language-csharp">
                <code class="language-csharp">
                  public class DatabaseConnectionManager
                  {
                      private IDbConnection _connection;

                      public DatabaseConnectionManager() { }

                      public DatabaseConnectionManager(IDbConnection connection)
                      {
                          Connection = connection;
                      }

                      public required IDbConnection Connection
                      {
                          get => _connection;
                          init => _connection = value 
                            ?? throw new ArgumentNullException(nameof(value));
                      }

                      public void Open()
                      {
                          if (Connection.State != ConnectionState.Open)
                          {
                              Connection.Open();
                          }
                      }

                      public void Close()
                      {
                          if (Connection.State != ConnectionState.Closed)
                          {
                              Connection.Close();
                          }
                      }
                  }
                </code>
              </pre>
            </div>
            <p class="section__item">
              Teraz,
              <span class="section__code-fragment">
                DatabaseConnectionManager
              </span>
              reprezentuje <b>tylko połączenie z bazą danych</b>, które posiada każda z naszych klas.
              Możemy <em>skorzystać</em> z
              <span class="section__code-fragment">
                DatabaseConnectionManager
              </span>
              jeśli tego potrzebujemy, ale nie <em>musimy</em>.
              Jeśli wprowadzimy bazę danych, która nie wspiera otwierania i zamykania połączeń, po prostu to
              zignorujemy.
            </p>
            <h3 class="section__item" id="from-inheritance">
              Od dziedziczenia do kompozycji
            </h3>
            <p class="section__item">
              Jak więc zastosować to w naszych klasach baz danych?
              Zamiast dziedziczyć po
              <span class="section__code-fragment">Database</span>
              , nasze klasy mogą teraz komponować obiekt
              <span class="section__code-fragment">DatabaseConnectionManager</span>.
            </p>
            <div class="code__wrapper">
              <pre class="line-numbers language-csharp">
              <code class="language-csharp">
              public sealed class MySql
              {
                  private readonly DatabaseConnectionManager _connectionManager;

                  public MySql() { }

                  public MySql(DatabaseConnectionManager connectionManager)
                  {
                      ConnectionManager = connectionManager;
                  }

                  public required DatabaseConnectionManager ConnectionManager
                  {
                      init => _connectionManager = value
                          ?? throw new ArgumentNullException(nameof(ConnectionManager));
                  }

                  public MySqlConnection MySqlConnection => 
                      (MySqlConnection)_connectionManager.Connection;

                  public IDataReader ExecuteSqlQuery(
                      string sql,
                      CommandType commandType = CommandType.Text,
                      params IDataParameter[] queryParameters)
                  {
                      MySqlCommand command = 
                          (MySqlCommand)_connectionManager.Connection.CreateCommand();

                      command.CommandText = sql;
                      command.CommandType = commandType;

                      if (queryParameters != null)
                      {
                          foreach (var param in queryParameters)
                          {
                              command.Parameters.Add(param);
                          }
                      }

                      return command.ExecuteReader(CommandBehavior.CloseConnection);
                  }

                  public void Open() => _connectionManager.Open();
                  public void Close() => _connectionManager.Close();
              }

              public sealed class SqlServer
              {
                  // ...
              }

              public sealed class SimpleDb
              {
                  private readonly DatabaseConnectionManager _connectionManager;

                  public SimpleDb() { }

                  public SimpleDb(DatabaseConnectionManager connectionManager)
                  {
                      ConnectionManager = connectionManager;
                  }

                  public required DatabaseConnectionManager ConnectionManager
                  {
                      init => _connectionManager = value
                          ?? throw new ArgumentNullException(nameof(value));
                  }

                  public SimpleDbConnection SimpleDbConnection => 
                      (SimpleDbConnection)_connectionManager.Connection;

                  public void Open() => _connectionManager.Open();
                  public void Close() => _connectionManager.Close();
              }
              </code>
            </pre>
            </div>
            <h3 class="section__item" id="extracting-query">
              Wyodrębnienie wykonywania zapytań
            </h3>
            <p class="section__item">
              Widzieliśmy, jak zarządzać połączeniami do baz danych,
              ale uruchamianie zapytań SQL nadal jest wymieszane w naszych klasach baz danych.
              Rozdzielmy tę odpowiedzialność.
              <span class="section__code-fragment">DatabaseSqlQueryExecutor</span>
            </p>
            <div class="code__wrapper">
              <pre class="line-numbers language-csharp">
                <code class="language-csharp">
                  public class DatabaseSqlQueryExecutor
                  {
                      private DatabaseConnectionManager _connectionManager;

                      public DatabaseSqlQueryExecutor() { }

                      public DatabaseSqlQueryExecutor(DatabaseConnectionManager connectionManager)
                      {
                          ConnectionManager = connectionManager;
                      }

                      public required DatabaseConnectionManager ConnectionManager
                      {
                          init => _connectionManager = value
                              ?? throw new ArgumentNullException(nameof(value));
                      }

                      public IDataReader ExecuteSqlQuery(
                          string sql,
                          CommandType commandType = CommandType.Text,
                          params IDataParameter[] queryParameters)
                      {
                          var command = _connectionManager.Connection.CreateCommand();
                          command.CommandText = sql;
                          command.CommandType = commandType;

                          if (queryParameters != null)
                          {
                              foreach (var param in queryParameters)
                              {
                                  command.Parameters.Add(param);
                              }
                          }

                          return command.ExecuteReader(CommandBehavior.CloseConnection);
                      }
                  }
                
                </code>
              </pre>
            </div>
            <p class="section__item">
              Teraz, zamiast umieszczać logikę zapytań wewnątrz naszych klas baz danych,
              możemy <em>wstrzykiwać</em>
              <span class="section__code-fragment">
                DatabaseSqlQueryExecutor
              </span>
              gdy tylko potrzebujemy uruchomić zapytania SQL.
            </p>
            <h3 class="section__item" id="putting-it-together">
              Składanie w całość
            </h3>
            <p class="section__item">
              Oto nasze ulepszone klasy
              <span class="section__code-fragment">
                MySql
              </span>
              i
              <span class="section__code-fragment">
                SqlServer
              </span>
              korzystające z obu komponentów.
            </p>
            <div class="code__wrapper">
              <pre class="line-numbers language-csharp">
                <code class="language-csharp">
                  public sealed class MySql
                  {
                      private readonly DatabaseConnectionManager _connectionManager;
                      private readonly DatabaseSqlQueryExecutor _queryExecutor;

                      public MySql() { }

                      public MySql(
                          DatabaseConnectionManager connectionManager,
                          DatabaseSqlQueryExecutor queryExecutor)
                      {
                          ConnectionManager = connectionManager;
                          QueryExecutor = queryExecutor;
                      }

                      public required DatabaseConnectionManager ConnectionManager
                      {
                          init => _connectionManager = value
                              ?? throw new ArgumentNullException(nameof(ConnectionManager));
                      }

                      public required DatabaseSqlQueryExecutor QueryExecutor
                      {
                          init => _queryExecutor = value
                              ?? throw new ArgumentNullException(nameof(QueryExecutor));
                      }

                      public MySqlConnection MySqlConnection =>
                          (MySqlConnection)_connectionManager.Connection;

                      public MySqlDataReader ExecuteSqlQuery(
                          string sql,
                          CommandType commandType = CommandType.Text,
                          params IDataParameter[] queryParameters)
                      {
                          return (MySqlDataReader)
                              _queryExecutor.ExecuteSqlQuery(sql, commandType, queryParameters);
                      }

                      public void Open() => _connectionManager.Open();
                      public void Close() => _connectionManager.Close();
                  }

                  public sealed class SqlServer
                  {
                      // ...
                  }
                </code>
              </pre>
            </div>
            <h3 class="section__item" id="why-better">
              Dlaczego to lepsze
            </h3>
            <p class="section__item">
              Na tym polega piękno kompozycji:
            </p>
            <ul class="section__list">
              <li class="section__list-item">
                <b>Potrzebujesz zarządzania połączeniami?</b> Użyj
                <span class="section__code-fragment">DatabaseConnectionManager</span>.
              </li>
              <li class="section__list-item">
                <b>Potrzebujesz wykonywać zapytania SQL?</b> Użyj
                <span class="section__code-fragment">DatabaseSqlQueryExecutor</span>.
              </li>
              <li class="section__list-item">
                <b>Nie potrzebujesz któregoś z nich?</b> Po prostu go nie dodawaj.
              </li>
            </ul>
            <p class="section__item">
              To sprawia, że nasza architektura jest <b>elastyczna</b> -
              każda klasa ma pojedynczą odpowiedzialność i może być użyta ponownie w innych miejscach.
            </p>
            <p class="section__item">
              Ale… coś istotnego straciliśmy po drodze.
            </p>
          </section>
          <section class="section__interfaces">
            <h1 class="section__item" id="interfaces">
              Interfejsy
            </h1>
            <p class="section__item">
              Przyjrzyjmy się relacjom między klasami, które mieliśmy na początku.
            </p>
            <figure class="section__uml-wrapper">
              <picture class="section__uml-inheritance-picture">
                <source srcset="/uml/uml-inheritance-light.svg" media="(prefers-color-scheme: light)"
                  class="section__uml-image">
                <source srcset="/uml/uml-inheritance-dark.svg" media="(prefers-color-scheme: dark)"
                  class="section__uml-image">
                <img src="/uml/uml-inheritance-dark.svg" alt="UML inheritance diagram" class="section__uml-image">
              </picture>
              <figcaption>
                Pierwotna struktura dziedziczenia
              </figcaption>
            </figure>
            <h2 class="section__item" id="contracts-are-expectations">
              Kontrakty to oczekiwania
            </h2>
            <p class="section__item">
              Początkowo nasze klasy baz danych <b>dziedziczyły</b> po
              wspólnej klasie bazowej
              <span class="section__code-fragment">Database</span>.
              To działało jako <b>kontrakt</b>:
            </p>
            <p class="section__item section__item--em">
              <em>
                "Wszystkie moje klasy potomne będą miały przynajmniej te metody
                i te właściwości"
              </em>.
            </p>
            <p class="section__item">
              To pozwala nam na przykład stworzyć klasę
              <span class="section__code-fragment">DatabaseFactory</span>,
              która dynamicznie tworzy różne podklasy
              <span class="section__code-fragment">Database</span>.
            </p>
            <h3 class="section__item" id="database-factory">Implementacja fabryki baz danych</h3>
            <div class="code__wrapper">
              <pre class="line-numbers language-csharp">
                <code class="language-csharp">
                  public enum DatabaseType
                  {
                      MySql,
                      SqlServer,
                      SimpleDb
                  }

                  public static class DatabaseFactory
                  {
                      public static Database CreateDatabase(DatabaseType type, IDbConnection connection)
                      {
                          return type switch
                          {
                              DatabaseType.MySql => 
                                  new MySql((MySqlConnection)connection),
                              DatabaseType.SqlServer => 
                                  new SqlServer((SqlConnection)connection),
                              DatabaseType.SimpleDb => 
                                  new SimpleDb((SimpleDbConnection)connection),
                              _ => throw new 
                                  ArgumentException("Unsupported database type", nameof(type))
                          };
                      }
                  }
                </code>
              </pre>
            </div>
            <p class="section__item">
              Ale po przejściu na kompozycję nasze klasy stały się niezależne.
              Nie dzielą już wspólnej klasy bazowej, więc nie możemy traktować ich zamiennie.
            </p>
            <figure class="section__uml-wrapper">
              <picture class="section__uml-no-inheritance-picture">
                <source srcset="/uml/uml-no-inheritance-light.svg" media="(prefers-color-scheme: light)"
                  class="section__uml-image">
                <source srcset="/uml/uml-no-inheritance-dark.svg" media="(prefers-color-scheme: dark)"
                  class="section__uml-image">
                <img src="/uml/uml-no-inheritance-dark.svg" alt="UML no inheritance diagram" class="section__uml-image">
              </picture>
              <figcaption>
                Po złożeniu klas z komponentów
              </figcaption>
            </figure>
            <p class="section__item">
              Zauważ, że klasy już na nic nie wskazują.
            </p>
            <p class="section__item">
              Jeśli spróbujemy teraz zaimplementować klasę fabryki, otrzymamy błąd,
              ponieważ nie ma <span class="section__code-fragment">Database</span>
              <b>kontraktu</b>, który klasy by spełniały.
            </p>
            <h2 class="section__item" id="interfaces-as-contracts">
              Interfejsy jako kontrakty
            </h2>
            <h3 class="section__item" id="IDatabaseConnection">
              Wprowadzenie
              <span class="section__code-fragment">IDatabaseConnection</span>
            </h3>
            <p class="section__item">
              Naprawimy to, używając <b>interfejsu</b>.
            </p>
            <div class="code__wrapper">
              <pre class="line-numbers language-csharp">
              <code class="language-csharp">
                public interface IDatabaseConnection
                {
                    void Open();
                    void Close();
                }
              </code>
            </pre>
            </div>
            <p class="section__item">
              Zaimplementujmy ten interfejs. Wystarczy zmienić trzy linie.
            </p>
            <div class="code__wrapper">
              <pre class="line-numbers language-csharp">
              <code class="language-csharp">
                public sealed class MySql : IDatabaseConnection
                public sealed class SqlServer : IDatabaseConnection
                public sealed class SimpleDb : IDatabaseConnection
              </code>
            </pre>
            </div>
            <p class="section__item">
              Dzięki temu nasze klasy ponownie dzielą wspólny kontrakt -
              ale zamiast dziedziczenia używamy <b>interfejsów</b>.
            </p>
            <figure class="section__uml-wrapper">
              <picture class="section__uml-interface-picture">
                <source srcset="/uml/uml-interface-light.svg" media="(prefers-color-scheme: light)"
                  class="section__uml-image">
                <source srcset="/uml/uml-interface-light.svg" media="(prefers-color-scheme: dark)"
                  class="section__uml-image">
                <img src="/uml/uml-interface-light.svg" alt="UML no inheritance diagram" class="section__uml-image">
              </picture>
              <figcaption>
                Po dodaniu interfejsów do klas
              </figcaption>
            </figure>
            <p class="section__item">Spróbujmy teraz ponownie zaimplementować naszą
              <span class="section__code-fragment">DatabaseFactory</span>
              klasę
            </p>
            <h3 class="section__item" id="interfaced-factory">
              Implementacja fabryki z interfejsem
            </h3>
            <div class="code__wrapper">
              <pre class="line-numbers language-csharp">
                <code class="language-csharp">
                  public enum DatabaseType
                  {
                      MySql,
                      SqlServer,
                      SimpleDb
                  }

                  public static class DatabaseFactory
                  {
                      public static IDatabaseConnection CreateDatabase(DatabaseType type, 
                                                                      IDbConnection connection)
                      {
                          var connectionManager = new DatabaseConnectionManager(connection);

                          return type switch
                          {
                              DatabaseType.MySql => 
                                  new MySql(connectionManager, 
                                            new DatabaseSqlQueryExecutor(connectionManager)),
                              DatabaseType.SqlServer => 
                                  new SqlServer(connectionManager, 
                                                new DatabaseSqlQueryExecutor(connectionManager)),
                              DatabaseType.SimpleDb => 
                                  new SimpleDb(connectionManager),
                              _ => throw new ArgumentException("Unsupported database type", nameof(type))
                          };
                      }
                  }
                </code>
              </pre>
            </div>
            <p class="section__item">
              Świetnie, wróciliśmy do tego, co mieliśmy wcześniej.
              Moglibyśmy uprościć hierarchię za pomocą interfejsu
              <span class="section__code-fragment">
                IDatabaseSql
              </span>
              ale tego nie będę omawiał.
            </p>
            <h2 class="section__item" id="from-inheritance-to-contracts">
              Od dziedziczenia do elastycznych kontraktów
            </h2>
            <p class="section__item">
              Przeszliśmy od <b>dziedziczenia</b> do <b>kompozycji</b>, aby zyskać większą elastyczność.
            </p>
            <ul class="section__list">
              <li class="section__list-item">
                <b>Kompozycja</b> daje nam komponenty wielokrotnego użytku (
                <span class="section__code-fragment">DatabaseConnectionManager</span>,
                <span class="section__code-fragment">DatabaseSqlQueryExecutor</span>
                ).
              </li>
              <li class="section__list-item">
                <b>Interfejsy</b> dają nam polimorfizm (umożliwiają traktowanie wszystkich klas baz danych tak samo).
              </li>
              <li class="section__list-item">
                Razem sprawiają, że nasza architektura jest czyściejsza, bardziej elastyczna i łatwiejsza do rozbudowy.
              </li>
            </ul>
            <p class="section__item">
              Teraz jesteśmy gotowi, by w końcu zająć się wstrzykiwaniem zależności.
            </p>
          </section>
          <section class="section__dependency-injecton" id="dependency-injection">
            <h1 class="section__item">
              Depndency injection
            </h1>
            <p class="section__item">
              Czym właściwie jest wstrzykiwanie zależności? Już je widziałeś!
            </p>
            <p class="section__item">
              Przypomnij sobie te fragmenty kodu z wcześniejszych przykładów:
            </p>
            <div class="code__wrapper">
              <pre class="line-numbers language-csharp" data-line="1">
                <code class="language-csharp">
                  public Database(IDbConnection connection)
                      {
                          Connection = connection;
                      }
                </code>
              </pre>
            </div>
            <div class="code__wrapper">
              <pre class="line-numbers language-csharp" data-line="2-3">
                <code class="language-csharp">
                  public MySql(
                          DatabaseConnectionManager connectionManager,
                          DatabaseSqlQueryExecutor queryExecutor)
                      {
                          ConnectionManager = connectionManager;
                          QueryExecutor = queryExecutor;
                      }
                </code>
              </pre>
            </div>
            <h2 class="section__item" id="what-does-injection-mean">Co oznacza "wstrzykiwanie"?</h2>
            <p class="section__item">
              Dependency injection (DI) to wzorzec projektowy, w którym klasa otrzymuje potrzebne obiekty
              (zależności)
              z <b>zewnątrz</b>, zamiast tworzyć je sama.
            </p>
            <p class="section__item">
              Zwykle <b>wstrzykujesz</b> je przez konstruktor lub właściwość. To właśnie czyni wstrzykiwanie zależności
              tak potężnym.
            </p>
            <div class="section__information-block">
              <div class="information__text">
                <div class="information__beginning">
                  <img src="/information-icon.svg" class="section__info-icon" alt="ikonka informacji">
                  <h3 class="section__item">Z zewnątrz, nie wewnątrz</h3>
                </div>
                Jeśli tworzysz zależności wewnątrz swojej klasy za pomocą
                <span class="section__code-fragment">new</span>
                , ściśle łączysz klasę z tymi implementacjami. Dzięki DI przekazujesz je z zewnątrz, co sprawia, że kod
                jest bardziej wielokrotnego użytku
                i łatwiejszy do zmiany.
              </div>
            </div>
            <h3 class="section__item">
              Co w tym takiego ważnego?
            </h3>
            <p class="section__item">
              Lubię myśleć o tym jak o <em>wzorcu puzzli</em>.
            </p>
            <p class="section__item">
              Wyobraź sobie, że budujesz z puzzli. Każdy kawałek jest niezależny i można go wymienić.
            </p>
            <p class="section__item">
              Jeśli budujesz komponenty oddzielnie (jak <span
                class="section__code-fragment">IDatabaseConnection</span>),
              zamiana jednego wpływa na wszystkie podklasy automatycznie, bez przepisywania wszystkiego.
            </p>
            <h2 class="section__item" id="testing-with-di">
              Testowanie z DI
            </h2>
            <p class="section__item">
              Uczyńmy to bardziej konkretnym. Załóżmy, że mamy klasę
              <span class="section__code-fragment">
                DatabaseSqlQueryExecutor
              </span>
              która zapisuje wyniki zapytań do pliku, korzystając z klasy
              <span class="section__code-fragment">
                SqlToFile
              </span>
              która sama używa klasy
              <span class="section__code-fragment">
                SqlEncryption
              </span>
              do szyfrowania danych.
            </p>
            <p class="section__item">
              Najpierw zmodyfikujmy
              <span class="section__code-fragment">DatabaseSqlQueryExecutor</span>
            </p>
            <div class="code__wrapper">
              <pre class="line-numbers language-csharp">
                <code class="language-csharp">
                  public class DatabaseSqlQueryExecutor
                  {
                      private readonly DatabaseConnectionManager _connectionManager;
                      private readonly SqlToFile _sqlToFile;

                      public DatabaseSqlQueryExecutor() { }

                      public DatabaseSqlQueryExecutor(DatabaseConnectionManager connectionManager, SqlToFile sqlToFile)
                      {
                          ConnectionManager = connectionManager;
                          SqlToFile = sqlToFile;
                      }

                      public required DatabaseConnectionManager ConnectionManager
                      {
                          init => _connectionManager = value
                              ?? throw new ArgumentNullException(nameof(value));
                      }

                      public required SqlToFile SqlToFile
                      {
                          init => _sqlToFile = value
                              ?? throw new ArgumentNullException(nameof(value));
                      }

                      public IDataReader ExecuteSqlQuery(
                          string sql,
                          CommandType commandType = CommandType.Text,
                          params IDataParameter[] queryParameters)
                      {
                          var command = _connectionManager.Connection.CreateCommand();
                          command.CommandText = sql;
                          command.CommandType = commandType;

                          if (queryParameters != null)
                          {
                              foreach (var param in queryParameters)
                              {
                                  command.Parameters.Add(param);
                              }
                          }

                          return command.ExecuteReader(CommandBehavior.CloseConnection);
                      }

                      public void ExecuteQueryAndWriteToFile(
                          string sql,
                          string filePath,
                          CommandType commandType = CommandType.Text,
                          params IDataParameter[] queryParameters)
                      {
                          using IDataReader reader = ExecuteSqlQuery(sql, commandType, queryParameters);
                          _sqlToFile.WriteToFile(reader, filePath);
                      }
                  }
                </code>
              </pre>
            </div>
            <h3 class="section__item" id="SqlToFile">
              Implementacja klasy <span class="section__code-fragment">SqlToFile</span>
            </h3>
            <p class="section__item">
              Klasa <span class="section__code-fragment">SqlToFile</span> używa wstrzykniętego
              obiektu <span class="section__code-fragment">SqlEncryption</span>, aby zaszyfrować każdy wiersz przed
              zapisaniem:
            </p>
            <div class="code__wrapper">
              <pre class="line-numbers language-csharp">
                <code class="language-csharp">
                  public class SqlEncryption : ISqlEncryption
                  {
                      private readonly _secretKey;

                      public Encrypt(string row) 
                      {
                          // Logika szyfrowania
                      }
                  }

                  public class SqlToFile
                  {
                      private readonly SqlEncryption _encryption;

                      public SqlToFile() { }

                      public SqlToFile(SqlEncryption encryption)
                      {
                          Encryption = encryption;
                      }

                      public required SqlEncryption Encryption
                      {
                          init => _encryption = value
                              ?? throw new ArgumentNullException(nameof(value));
                      }

                      public void WriteToFile(IDataReader reader, string filePath)
                      {
                          using var writer = new StreamWriter(filePath, false, Encoding.UTF8);

                          for (int i = 0; i &lt; reader.FieldCount; i++)
                          {
                              string columnName = reader.GetName(i);
                              writer.Write(columnName);
                              if (i &lt; reader.FieldCount - 1)
                              {
                                  writer.Write(",");
                              }
                          }
                          writer.WriteLine();

                          while (reader.Read())
                          {
                              string[] rowData = new string[reader.FieldCount];
                              for (int i = 0; i &lt; reader.FieldCount; i++)
                              {
                                  object value = reader.GetValue(i);
                                  rowData[i] = value != null ? value.ToString()! : string.Empty;
                              }

                              string row = string.Join(",", rowData);

                              string encryptedRow = _encryption.Encrypt(row);
                              writer.WriteLine(encryptedRow);
                          }
                      }
                  }
                </code>
              </pre>
            </div>
            <p class="section__item">
              Ale podczas testów, jeśli chcemy sprawdzić, czy zawartość jest zapisywana poprawnie,
              czy nie wolelibyśmy widzieć zwykłego tekstu bez szyfrowania?
            </p>
            <p class="section__item">
              To jest sedno wstrzykiwania zależności.
            </p>
            <h2 class="section__item" id="injection-factory">Użycie fabryki do wstrzykiwania</h2>
            <p class="section__item">
              Zmodyfikujmy naszą fabrykę tak, by móc przekazać dowolną implementację
              <span class="section__code-fragment">ISqlEncryption</span>:
            </p>
            <div class="code__wrapper">
              <pre class="line-numbers language-csharp">
                <code class="language-csharp">
                  public static class DatabaseFactory
                  {
                      public static IDatabaseConnection CreateDatabase(DatabaseType type, 
                                                                      IDbConnection connection,
                                                                      ISqlEncryption? encryption)
                      {
                          var connectionManager = new DatabaseConnectionManager(connection);

                          return type switch
                          {
                              DatabaseType.MySql => 
                                  new MySql(connectionManager, 
                                            new DatabaseSqlQueryExecutor(connectionManager,
                                                                        encryption)),
                              DatabaseType.SqlServer => 
                                  new SqlServer(connectionManager, 
                                                new DatabaseSqlQueryExecutor(connectionManager,
                                                                            encryption)),
                              DatabaseType.SimpleDb => 
                                  new SimpleDb(connectionManager),
                              _ => throw new ArgumentException("Unsupported database type", nameof(type))
                          };
                      }
                  }
                </code>
              </pre>
            </div>
            <h2 class="section__item" id="puzzle-piece">
              Wzorzec puzzli
            </h2>
            <p class="section__item">
              Teraz możemy zastąpić
              <span class="section__code-fragment">
                SqlEncryption
              </span> przyjazną dla testów klasą atrapą, która nic nie robi:
            </p>
            <div class="code__wrapper">
              <pre class="line-numbers language-csharp">
                <code class="language-csharp">
                  public class TestSqlEncryption : ISqlEncryption
                  {
                      private readonly string _secretKey = String.empty;

                      public Encrypt(string row) 
                      {
                          return row;
                      }
                  }
                </code>
              </pre>
            </div>
            <p class="section__item">I wstrzykujemy ją tak:</p>
            <div class="code__wrapper">
              <pre class="line-numbers language-csharp">
                <code class="language-csharp">
                  TestSqlEncryption testSqlEncryption = new ("Testing");

                  MySql mySqlDb = DatabaseFactory.CreateDatabase(
                      DatabaseType.MySql,
                      new MySqlConnection
                      {
                          ConnectionString = "...";
                      },
                      testSqlEncryption
                  );

                  SqlServer sqlServerDb = DatabaseFactory.CreateDatabase(
                      DatabaseType.SqlServer,
                      new MySqlConnection
                      {
                          ConnectionString = "...";
                      },
                      testSqlEncryption
                  );
                </code>
              </pre>
            </div>
            <p class="section__item">
              Gdyby każda klasa bazy danych tworzyła własny obiekt szyfrowania wewnętrznie, trzeba by je wszystkie
              zmieniać
              podczas testów.
            </p>
            <p class="section__item">
              Dzięki DI zmieniasz to tylko w jednym miejscu.
            </p>
          </section>
          <section class="secton__conclusion">
            <h1 class="section__item" id="conclusion">
              Podsumowanie
            </h1>
            <p class="section__item">
              W tym artykule prześledziliśmy ewolucję podejść opartych na dziedziczeniu do używania interfejsów,
              a w końcu do wstrzykiwania zależności (DI). Początkowo dziedziczenie służyło do dzielenia się zachowaniem,
              ale często prowadziło do sztywnego i silnie powiązanego kodu.
            </p>
            <p class="section__item">
              Wprowadzenie interfejsów pozwoliło nam definiować kontrakty, które mogły implementować różne klasy,
              co promowało elastyczność i rozluźnienie powiązań. Jednak nawet z interfejsami klasy często tworzyły
              własne
              zależności wewnętrznie, co ograniczało testowalność i ponowne użycie.
            </p>
            <p class="section__item">
              Wstrzykiwanie zależności rozwiązuje te problemy przez odwrócenie kontroli: zależności są przekazywane z
              zewnątrz,
              zamiast być tworzone wewnątrz klasy. Ta zmiana poprawia modułowość, ułatwia wymianę implementacji
              i znacząco usprawnia testowanie przez umożliwienie użycia mocków lub stubów.
            </p>
            <p class="section__item">
              Przechodząc od dziedziczenia, przez interfejsy, aż do DI, budujemy oprogramowanie bardziej utrzymywalne,
              elastyczne i zgodne z nowoczesnymi najlepszymi praktykami.
            </p>
          </section>
    </main>

    <footer class="layout__footer">
      <a href="https://github.com/tkwiatkowskii" class="footer__github-icon" target="_blank" rel="noopener noreferrer">
        <img src="/github-mark-white.svg" alt="github link icon">
      </a>
      <address class="footer__contact-information">
        <a href="mailto:tomaszkwiatkowski191@gmail.com">tomaszkwiatkowski191@gmail.com</a>
      </address>
    </footer>
  </div>
  <script type="module" src="/src/scripts/main.ts" defer></script>
</body>

</html>